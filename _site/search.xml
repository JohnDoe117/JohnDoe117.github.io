<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Leecode-002]]></title>
      <url>/leecode/2018/08/22/leecode-002/</url>
      <content type="text"><![CDATA[题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。题解代码 class Solution:    def removeDuplicates(self, nums):        """        :type nums: List[int]        :rtype: int        """        i = 0        while i &lt; len(nums)-1:            if nums[i] == nums[i+1]:                nums.remove(nums[i])                遇到重复就把重复的元素删除掉            else:                i += 1        return len(nums)解题思路这个函数在使用的时候传递的是引用值，即为函数操作之后传入变量的值也会发生改变，即在原有列表上操作（原地去重）。]]></content>
      <categories>
        
          <category> Leecode </category>
        
      </categories>
      <tags>
        
          <tag> Leecode easy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Leecode-001]]></title>
      <url>/leecode/2018/08/22/leecode-001/</url>
      <content type="text"><![CDATA[题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]题解代码 def twoSum(self, nums, target):        """        :type nums: List[int]        :type target: int        :rtype: List[int]        """        for k, i in enumerate(nums):            if target - i in nums[k + 1:]:                return [k, nums[k + 1:].index(target - i) + k + 1]解题思路第一次题解使用暴力二重循环解决这个问题。然后发现可以简单使用一层循环实现遇到和为target直接返回]]></content>
      <categories>
        
          <category> Leecode </category>
        
      </categories>
      <tags>
        
          <tag> Leecode easy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
