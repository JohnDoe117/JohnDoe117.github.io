<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[]]></title>
      <url>/2018/08/23/2018-08-23-portia%E5%88%9D%E6%8E%A2/</url>
      <content type="text"><![CDATA[官方文档这是portia的官方文档地址https://portia.readthedocs.io/en/latest/第一步安装docker（推荐安装方式）Ubuntu：sudo apt-get install docker.iopip install docker-compose（速度过慢可以使用阿里的加速器）MAC：docker官网下载对应dmg包安装即可下载启动portia镜像并启动docker run -i -t --rm -v /Users/&lt;username&gt;/Projects/portia_projects:/app/data/projects:rw -p 9001:9001 scrapinghub/portia此时访问127.0.0.1:9001即可打开portia后续目前使用也是仅仅将环境部署并做简单尝试，后续高级功能会再做介绍。]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Leecode-007]]></title>
      <url>/leecode/2018/08/22/leecode-007/</url>
      <content type="text"><![CDATA[题目给定一个 32 位有符号整数，将整数中的数字进行反转。示例输入: 123输出: 321输入: -123输出: -321输入: 120输出: 21其他限制条件假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。题解代码 class Solution:    def reverse(self, x):        """        :type x: int        :rtype: int        """        a = int(str(abs(x))[::-1])        #先取x的绝对值将其倒置然后转换为整数        if -2147483648 &lt; a &lt; 2147483647:  #整数不溢出的条件            if x &lt; 0:            #如果原数字是负数为其添加负号                a = -a            return a        else:            return 0 解题思路这个题操作是将数字反转，我们很自然想到可以使用[::-1]的方法获得反转的字符串，然后转化为int类型可以去掉前导零，如果使用字符串操作可以使用rstrip('0')去掉左边的‘0’字符]]></content>
      <categories>
        
          <category> Leecode </category>
        
      </categories>
      <tags>
        
          <tag> Leecode easy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Leecode-002]]></title>
      <url>/leecode/2018/08/22/leecode-002/</url>
      <content type="text"><![CDATA[题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。题解代码 class Solution:    def removeDuplicates(self, nums):        """        :type nums: List[int]        :rtype: int        """        i = 0        while i &lt; len(nums)-1:            if nums[i] == nums[i+1]:                nums.remove(nums[i])                遇到重复就把重复的元素删除掉            else:                i += 1        return len(nums)解题思路这个函数在使用的时候传递的是引用值，即为函数操作之后传入变量的值也会发生改变，即在原有列表上操作（原地去重）。]]></content>
      <categories>
        
          <category> Leecode </category>
        
      </categories>
      <tags>
        
          <tag> Leecode easy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Leecode-001]]></title>
      <url>/leecode/2018/08/22/leecode-001/</url>
      <content type="text"><![CDATA[题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]题解代码 def twoSum(self, nums, target):        """        :type nums: List[int]        :type target: int        :rtype: List[int]        """        for k, i in enumerate(nums):            if target - i in nums[k + 1:]:                return [k, nums[k + 1:].index(target - i) + k + 1]解题思路第一次题解使用暴力二重循环解决这个问题。然后发现可以简单使用一层循环实现遇到和为target直接返回]]></content>
      <categories>
        
          <category> Leecode </category>
        
      </categories>
      <tags>
        
          <tag> Leecode easy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
